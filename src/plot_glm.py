"""Convert GridLAB-D model to a network plot image

Options:
  -B|--base=<float>     Set the power base (default 1kW)
  --color (str)         Set the node and link color (default by phase)
  --install             Install this copy as the GridLAB-D tool
  -i|--input=<str>      Set the input file name (GLM or JSON)
  -L|--layout=<str>     Choose the layout method (default "kamada_kawai")
  -N|--nodeshape=<str>  Set the node shape (default by phase)
  -o|--output=<str>     Set the output file name
  -S|--show[=<bool>]    Show the image (default False)
  -t|--timeout=<int>    Set the activity timeout in seconds (default None)
  -T|--title[=<str>]    Enable or set the image title (default False)
  -W|--workdir=<str>    Set the working directory (default ".")
  --width=<int>         Set the link width (default by power)
  -Z|--nodesize=<int>   Set the node size (default 50)

Generate a network plot from a GLM or JSON file.  The 'base' option sets
the power base used to set the width of links, which is logarithmic with
the power base as width 1 and factors of 10 increasing the width by 1.
The layout can be selected from among the layout allowed by the networkx
module.  The nodeshape option specifies the shape of nodes. The nodesize 
is an integer. The show option enables immediately showing a plot. The
workdir option specifies the working folder.

If the input file is not JSON, it is automatically converted to JSON. If
the output file is not specified and the show option is not given, then
the output file is set to the input file with the extension ".png".

If no options are given and the folder "autotest" is found, then the
autotest procedure is run on all the GLM files found in the folder.  The
file "validate.txt" is generated by the procedure.

Link and node colors are based on the phases, with red for phase A, green 
for phase B, and blue for phase C. Node shapes are automatically set based 
on the phase specification. Split phases are depicted as a diamond, delta
as a caret, wye/neutral as a vee, otherwise as a circle. If you specify
node shape, the phase information is ignored.
"""
import os, sys
import subprocess
import json
import math
import networkx
import matplotlib.pyplot as plt
import traceback
import signal

BASENAME = os.path.splitext(os.path.basename(sys.argv[0]))[0]
INPUTFILE = None
OUTPUTFILE = None
SHOWPLOT = False
WORKDIR = "."
OUTPUT = ""
ERRORS = ""
BASEPOWER = 1e3
GRAPHLAYOUT = "kamada_kawai"
TIMEOUT = None 
TITLE = False
NODESIZE = 50
NODESHAPE = None
NODECOLOR = None
LINKWIDTH = None

E_OK = 0
E_FAILED = 1
E_SYNTAX = 2
E_TIMEOUT = 3

RETURNCODE = 0

class ConverterException(Exception):
    pass

class ConverterTimeout(Exception):
    pass

def error(msg,code=None):
    print(f"ERROR [{BASENAME}]: {msg}")
    if type(code) is int:
        exit(code)
    elif type(code) is Exception:
        raise code(msg)

def color(phases):
    if NODECOLOR:
        return NODECOLOR
    r = 255 if "A" in phases else 0
    g = 255 if "B" in phases else 0
    b = 255 if "C" in phases else 0
    if [r,g,b] == [255,255,255]:
        return "black"
    else:
        return f"#{r:02x}{g:02x}{b:02x}"

def shape(phases):
    if NODESHAPE:
        return NODESHAPE
    if "S" in phases:
        return "d" 
    elif "D" in phases:
        return "^"
    elif "N" in phases:
        return "o"
    else:
        return "v"

def convert(inputfile=None,
        outputfile=None,
        showplot=False,
        jsonfile=None,
        workdir="."):

    if not inputfile:
        inputfile = INPUTFILE

    if not outputfile:
        outputfile = OUTPUTFILE

    if not inputfile.endswith(".json"):
        if not jsonfile:
            jsonfile = os.path.splitext(inputfile)[0] + ".json"
        result = subprocess.run(["gridlabd",
                "-W",workdir,
                "-I",inputfile,
                "-o",jsonfile],
            stdout = subprocess.PIPE,
            stderr = subprocess.STDOUT)
        global OUTPUT
        global ERRORS
        OUTPUT = ""
        ERRORS = ""
        if result.returncode:
            ERRORS = result.stdout.decode()
            return result.returncode
        else:
            OUTPUT = result.stdout.decode()
        inputfile = jsonfile

    if not outputfile and not showplot:
        outputfile = os.path.splitext(inputfile)[0] + ".png"

    # print(f"convert(inputfule={inputfile},ouputfile={outputfile},showplot={showplot},jsonfile={jsonfile},workdir={workdir})")

    with open(f"{workdir}/{inputfile}",'r') as fh:
        
        glm = json.load(fh)
        plt.figure(figsize=(10,7))
        G = graph(glm)
        if TITLE:
            if TITLE == True:
                title = os.path.splitext(os.path.basename(inputfile))[0]
            else:
                title = TITLE
                print("TITLE =",title)
            plt.suptitle(title)
        if outputfile:
            plt.savefig(outputfile)
        if showplot:
            plt.show()
        plt.close()
        return E_OK
    return E_FAILED

def graph(glm):
    G = networkx.Graph()
    link = []
    node = []
    objects = glm['objects']
    idlist = {}
    for name,data in objects.items():
        idlist[name] = data['id']
    for name,data in objects.items():
        if 'from' in data and 'to' in data:
            link.append(idlist[name])
            from_node = idlist[data['from']]
            to_node = idlist[data['to']]
            if from_node not in node:
                node.append(from_node)
                phases = objects[data['from']]['phases']
                G.add_node(from_node,
                    color = color(phases),
                    edge = "black" if "N" in phases else "white",
                    shape = shape(phases))
            if to_node not in node:
                node.append(to_node)
                phases = objects[data['to']]['phases']
                G.add_node(to_node,
                    color = color(phases),
                    edge = "black" if "N" in phases else "white",
                    shape = shape(phases))
            weight = math.log10(abs(complex(data["power_out"]\
                        .split()[0]).real/BASEPOWER)+10)
            if weight <= 0:
                raise ConverterException(f"{name}: weight<=0; power = {data['power_out']}")
            G.add_edge(from_node, to_node,
                    color = color(data["phases"]),
                    weight = weight)

    edge_colors = list(networkx.get_edge_attributes(G,'color').values())
    edge_weights = list(networkx.get_edge_attributes(G,'weight').values())
    node_colors = list(networkx.get_node_attributes(G,'color').values())
    node_shapes = list(networkx.get_node_attributes(G,'shape').values())
    node_edges = list(networkx.get_node_attributes(G,'edge').values())
    node_pos = getattr(networkx,GRAPHLAYOUT+"_layout")(G)
    networkx.draw_networkx_edges(G,pos=node_pos,
        edge_color = edge_colors,
        width = list(edge_weights),
        )
    shape_table = list(enumerate(node_shapes))
    shape_names = list(node_pos.keys())
    for node_shape in set(node_shapes):
        index = [shape_names[i] for i,x in shape_table if x==node_shape]
        colors = [node_colors[i] for i,x in enumerate(node_shapes) if x==node_shape]
        networkx.draw_networkx_nodes(G,pos=node_pos,
            nodelist = index,
            node_color = colors,
            node_size = NODESIZE,
            node_shape = node_shape,
            )
    return G

def validate():
    tested = 0
    failed = 0
    TESTDIR = WORKDIR + "/autotest"
    with open("validate.txt","w") as fh:
        for file in sorted(os.listdir(TESTDIR)):
            if not file.endswith(".glm"):
                continue
            outputfile = f"{TESTDIR}/{file.replace('.glm','.png')}"
            print("Testing",file,flush=True,end='... ')
            if os.path.exists(outputfile):
                print("FOUND")
                tested += 1
                continue
            try:
                if TIMEOUT:
                        def timeout(signum,frame):
                            raise ConverterTimeout(f"timeout after {TIMEOUT} seconds")
                        signal.signal(signal.SIGALRM,timeout)
                        signal.alarm(TIMEOUT)

                if convert(file,
                        outputfile=outputfile,
                        workdir=TESTDIR):
                    failed += 1
                    print("*** TEST",file,"FAILED\n" + ERRORS,file=fh,flush=True)
                    print("",file=fh,flush=True)
                    print("FAILED")
                else:
                    print("OK")
                    print("*** TEST",file,"OK\n" + OUTPUT,file=fh,flush=True)
                    print("",file=fh,flush=True)
            except ConverterTimeout as err:
                print("TIMEOUT")
                print("*** TEST",file,"TIMEOUT\n",file=fh,flush=True)
                print("",file=fh,flush=True)
                failed += 1
            except Exception as err:
                print("EXCEPTION")
                print("*** TEST",file,"EXCEPTION\n",file=fh,flush=True)
                traceback.print_exception(err,file=fh)
                print("",file=fh,flush=True)
                failed += 1
            finally:
                tested += 1
                signal.alarm(0)
                plt.close()
    print(tested,"tested")
    print(failed,"failed")
    print(f"{(100-(100*failed)/tested):.0f}% passing")
    return (E_FAILED if failed else E_OK)

def install():
    if os.system(f"cp {sys.argv[0]} $(gridlabd --version=install)/share/gridlabd") != 0:
        error("install failed")

if __name__ == "__main__":
    for arg in sys.argv[1:]:
        spec = arg.split("=")
        if len(spec) == 1:
            tag = spec[0]
            value = True
        elif len(spec) == 2:
            tag = spec[0]
            value = spec[1]
        else:
            tag = spec[0]
            value = "=".join(spec[1:])
        if tag in ["-h","--help","help"]:
            print(__doc__)
            exit(E_OK)
        elif tag in ["--install"]:
            if sys.argv[1] != tag:
                error("--install must be used alone",E_SYNTAX)
            RETURNCODE = install()
            exit(RETURNCODE)
        elif tag in ['--color']:
            NODECOLOR = value
        elif tag in ['--width']:
            NODEWIDTH = value
        elif tag in ["-S","--show"]:
            SHOWPLOT = value
        elif tag in ["-W","--workdir"]:
            WORKDIR = value
        elif tag in ["-L","--layout"]:
            GRAPHLAYOUT = value
        elif tag in ["-B","--base"]:
            BASEPOWER = float(value)
        elif tag in ["-t","--timeout"]:
            TIMEOUT = int(value)
        elif tag in ["-T","--title"]:
            TITLE = value            
        elif tag in ["-i","--input"]:
            INPUTFILE = value
        elif tag in ["-o","--output"]:
            OUTPUTFILE = value
        elif tag in ["-N","--nodeshape"]:
            NODESHAPE = value
        elif tag in ["-Z","--nodesize"]:
            NODESIZE = int(value)
        else:
            error(f"option '{arg}' is invalid",1)

    if len(sys.argv) == 1 or not INPUTFILE:

        if os.path.exists(WORKDIR+"/autotest"):
        
            print("Validating in folder",WORKDIR+"/autotest")
            RETURNCODE = validate()
        
        else:
        
            print("Syntax:",
                os.path.splitext(os.path.basename(sys.argv[0]))[0],
                "[OPTIONS ...]")
            RETURNCODE = E_SYNTAX

    else:

        if TIMEOUT:
            def timeout(signum,frame):
                error("timeout",E_TIMEOUT)
            signal.signal(signal.SIGALRM,timeout)
            signal.alarm(TIMEOUT)

        RETURNCODE = convert(INPUTFILE,OUTPUTFILE,SHOWPLOT)

    exit(RETURNCODE)
